# Инструкция по работе с Git

## Общая информация

__Git - программа для контроля версий.__ 

В программировании проблема совместной работы над проектами возникла ещё до появления облачных сервисов. Для решения этой проблемы Линус Торвальдс (автор ОС Linux) и создал Git.  __Программа Git контролирует версии проекта и позволяет переключаться между ними.__ Одной из важных особенностей Git является то, что программа хранит не файлы целиком, а только изменения в них. Это позволяет экономить память.

## Основные команды Git

Все команды в Git транслируются пользователем следующим образом: **_git команда_**.

Так вот основные команды:
 
* *version* - показывает текущую версию Git
* *status* - показывает текущее состояние открытой папки, репозитория, файлов в репозитории
* *init* - инициализирует репозиторий в открытой папке
* *add файл* - добавляет файл в отслеживаемые
* *commit* - фиксирует внесенные в репозитории изменения
      
    * *commit -m* - только фиксирует изменения. Используется в основном при первом коммите добавленного файла
    * *commit -am* - добавляет файл и фиксирует изменения. Используется при повторных изменениях в рабочем файле репозитория
* *diff* - показывает разницу между текущим файлом и сохранённым
* *branch* - команда показывает все ветки репозитория
    * branch имя - создает новую ветку с наименованием **имя**
    * *branch -d имя* - удаляет ветку с наименованием **имя** после слива ветки **имя** в другую ветку. При этом позиция пользователя на момент удаления должна быть вне удаляемой ветки 
    * *branch -D имя* - удаляет ветку с наименованием **имя** без условий. При этом позиция пользователя на момент удаления должна быть вне удаляемой ветки 
    * *branch -M имя* - переименовывает ветку **имя**
* *log* - открывает журнал фиксаций (точек сохранения изменений) - коммитов
    * *log --graph* - открывает журнал фиксаций (точек сохранения изменений) - коммитов с графическим отображением веток и слияний
* *checkout имя* - позволяет перемещаться между коммитами или ветками с наименованием **имя**
* *merge имя* - сливает ветку **имя** в текущую ветку
* *clone ссылка на удалённый репозиторий* - клонирует удалённый репозиторий на локальный ПК (в нужную папку, которая предварительно открыта в Git)
* *cd имя* - переход в папку **имя**
* *push ссылка* - Отправляет изменения локального репозитория на GitHub по **ссылке**
* *pull* - обновляет состояние клонированного репозитория на локальном ПК. Команда составная. Она не только подгрузит изменения, которые зафиксированы в репозитории на GitHub, но и сольёт ветки из удалённого репозитория с ветками его локальной копии. 

## Начало работы

Для начала работы с Git необходимо, как минимум установить и настроить сам Git. Так как Git является бесплатной программой, то его возможно без проблем установить пройдя по ссылке [Установка Git](https://gitforwindows.org/ "Жми и установливай. Не заразно."). Для того, чтобы работать с Git также нужно установить [Visual Studio Code](https://code.visualstudio.com/ "Жми и установливай. Всё официально и совершенно бесплатно"). Для установки в различные ОС существуют нюансы, но о них вам с удовольствием расскажет Google и его "друзья".

После установки Git и VSC Git необходимо настроить. Как это сделать? Хороший вопрос... Я сейчас узнаю и напишу, так как у меня это всё получилось как-то интуитивно и без проблем, так что и у вас, уверен, проблем не будет... ...так вот первоначальная настройка очень проста:

1. Необходимо ***установить имя*** под которым вы будете работать в Git. Сделать это можно с помощью команды `git config --global user.name "<ваше_имя>"`, где ваше имя - это произвольное имя (на латинице) выбранное вами.
2. Необходимо ***установить адрес электронной почты*** под которым вы будете работать в Git. Сделать это можно с помощью команды `git config --global user.email "<адрес_почты@email.com>"`, где, **выбранный вами адрес электронной почты - это ваш почтовый ящик.**

Данные действия необходимы для персонализации вас как автора ваших действий в Git. Например, при совместном написании кода другие разработчики могут понять чьих рук дело - все самые дерьмовые строчки кода.

## Работа с репозиторием

*__Репозиторий__ - это хранилище файлов, поддерживающее версионность.*

1. ### Создание  Git-репозитория
* Берём локальную папку, которая не находится под версионным контролем,  и превращаем её в репозиторий или клонируем существующий репозиторий  из любого места.     
  * Инициализация репозитория осуществляется с помощью команды `git init`. (После инициализации в папке автоматически создаётся скрытая папка .git, которая и является "управленцем" любого репозитория)
  * Клонирование осуществляется с помощью команды `git clone`. Также можно использовать команду `git pull`, но это история по работе с удалёнными репозиториями.
  
* Создаём рабочий файл (с обязательным указанием расширения), добавляем его в отслеживаемые и можно приступать к работе.
  * Добавление файла осуществляется с помощью команды `git add`.

  * с помощью команды `git commit -m "init commit"` делаем первый коммит.

  *После проделанных манипуляций можно приступать к работе с файлом*

  Если вы читаете это, то слив ветки WorkWithRepozitory в основную ветку произведен по плану.
  
## Работа с ветками

**Работа  с ветками нужна для того, чтобы вожно было вносить изменения и дополнения в проект без вмешательства в основной проект и только после проверки качества своей ветки сливать её в основную ветку.**

1. Работа с ветками начинается с команды `git branch`, которая позволяет узнать сколько веток у вас есть, как они называются и на какой из них в данный момент вы находитесь.

2. Чтобы создать новую ветку необходимо использовать команду `git branch имя ветки`. Не забывать "Комитить" создание новой ветки.

3. Чтобы перейти на новую (или просто отдельную ветку) необходимо воспользоваться командой `git checkout имя ветки (на которую нужно перейти)`

4. После внесения изменений в новую ветку "комитим" (вот и я уже, к сожалению, приобщаюсь к сленгу) изменения, а потом переходим в главную ветку и сливаем в неё новую ветку со всеми изменениями.

5. После слияния новую ветку можно удалить воспользовавшись командой `git branch -d имя удаляемой ветки`

## Работа с изображениями и ссылками

     Я начинаю работу с данным разделом в ветке **Работа_с_изображениями_и_ссылками**. Этот текст при слиянии останется. Я надеюсь.

Чтобы добавить в рабочий файл изображение необходимо поизвести следующие действия:

1. Добавить файл с изображением в папку нашего репозитория
2. Создать в репозитории файл `.gitignore`. Этот файл является обязательным в любом репозитории (как и файл README но об этом позже). В файл `.gitignore` добавляются все файлы, любых типов, отслеживать которые нет необходимости. Добавить файлы можно несколькими способами:
    
     * добавить игнорируемого файла в файл `.gitignore` с **обязательным указанием расширения файла** и всё это деле, естественн, "закоммитить".
     * если файлов одного типа для игнорирования много, то в `.gitignore` нужно прписать следующее: "*.расширение игнорируемых файлов" и, естественно, это дело "закоммитить".
     * если файлов одного типа для игнорирования много и они в разных папках, то в `.gitignore` нужно прписать следующее: "*/.расширение игнорируемых файлов" и, естественно, это дело "закоммитить".

     Хочу обратить внимание, что на одном из семинаров я узнал, благодаря вопросу сокурсника, что в случае, когда из множества файлов одного типа игнорировать нужно не все, то в `.gitignore` придётся вписывать каждый подлежащий игнору файл вручную. Как говори один телеведущий вечерней передачи для детей: "Отака хуйня, малята!"
3. Теперь приступим к добавлению изображений. Это будут изображения конфликтов. И делается это так:
![conflict_branch_StartWork.png](conflict_branch_StartWork.png "конфликт при сливе ветки StartWork в основную ветку")

   ![conflict_branch_WorkWithBranches.png](conflict_branch_WorkWithBranches.png "конфликт при сливе ветки WorkWithBranches в основную ветку")

   ![conflict_merge_branch_boyarin_to_brunch_WorkWithRepozitory.png](conflict_merge_branch_boyarin_to_brunch_WorkWithRepozitory.png "конфликт при сливе ветки boyarin в ветку WorkWithRepozitory")

   ![conflict_merge_branch_WorkWithRepozitory_to_branch_Boyarin.png](conflict_merge_branch_WorkWithRepozitory_to_branch_Boyarin.png "конфликт при сливе ветки WorkWithRepozitory в ветку Boyarin")

Помимо изображений, похожим образом можно добавлять ссылки на содержимое из сети. Например, если вы долго сидите за компьютером, то вам не лишним будет [иногда пользоваться рекомендациями из данной ссылки](https://www.instagram.com/reel/CxTDawksFaN/?igshid=MzRlODBiNWFlZA== "Помогает! Проверял лично. Особенно полезно тем, у кого проблемы со спиной.")

Уточнения:

- изображения добавляются используя следующий набор и порядок символов`![имя файла. расширение](ссылка на файл: имя файла с расширением или же ссылка на удаленное изображение "комментарий, который будет отображаться при наведении курсора на изображение")`.

- ссылки из сети добавляются вот-так `![кликабельный текст, который видит пользователь](ссылка по которой пользователь попадёт туда куда вы его послали по этой ссылке "комментарий, который будет отображаться при наведении курсора на кликабельный текст")`.

На этом я заканчиваю редактирование данного раздела, так как больше ничего на ум не приходит. Но если в дальнейшем вспомню, то обязательно добавлю.

## Работа с конфликтами

При слиянии веток часто возникают конфликты. Это происходит, если содержимое сливаемой ветки отличается от содержимого ветки куда сливают

Возможные варианты действий следующие:

- можно не принимать изменения из сливаемой ветки, если они не являются полезными
- можно принять всю информацию из сливаемой ветки взамен информации в принимающей ветке
- можно принять оба варианта: данные из обеих веток дополнят друг друга
- можно самостоятельно решить конфликт, вручную выбрав те изменения, которые будут добавлены в принимающую ветку

*В разделе Работа с изображениями вы можете ознакомиться со снимками экрана некоторых конфликтов, возникших в ходе написания текущего проекта.*

*Если вы видите этот текст, то мне удалось по плану разрешить свой первый конфликт*

## Работа с удалёнными репозиториями

### Для работы с удаленным репозиторием на локальном ПК необходимо:
--- 

1. Копировать ссылку на удаленный репозиторий на GitHub 

2. Используя команду `git clone` и ссылку клонировать удалённый репозиторий на свой ПК (в нужную папку, которая предварительно открыта в git) 

3. С помощью команды `cd` с указанием имени клонированного репозитория перейти в клонированный репозиторий. 

4. С помощью команды `git branch` создать отдельную ветку (если это чужой проект) и внести изменения в созданную ветку. Естественно все эти изменения закомитить. 

5. Слить ветку-черновик в ветку **main**.  Естественно все эти изменения "закомитить". 
---

Чтобы обновить состояние клонированного репозитория на локальном ПК используют команду `git pull`. `git pull` команда составная. Она не только подгрузть изменения, которые зафиксированы в репозитории на GitHub, но и сольёт ветки из удалённого репозитория с ветками его локальной копии. 

### Отправка своего локального репозитория на GitHub
--- 

1. Для отправки мы "комитим" локальный репозиторий. 

2. Создаем (в случае отсутствия) аккаунт на ресурсе типа GitHub.  

3. В созданном аккаунте создаём новый репозиторий (присвоив ему уникальное имя). 

4. Используя подсказки GitHub добавляем локальный репозиторий во вновь созданный репозиторий на GitHub. 

5. При первом push (добавлении) в новый репозиторий необходимо авторизоваться (подружить Git с GitHub). Git  поможет это сделать своими подсказками. 

6. После авторизации мы можем добавлять изменения с локального репозитория с помощью команды `git push`. После использования команды обязательно необходимо обновить страницу репозитория на GitHub, чтобы изменения отобразились. 

### Участие в проектах других разработчиков:
--- 

1. В своём аккаунте GitHub с помощью **fork** создаём копию репозитория чужого проекта. 

2. С помощью команды `git clone` клонируем "форкнутый" репозиторий на локальный ПК. 

3. С помощью команды `cd` переходим в клонированный репозиторий. 

4. Чтобы предложить свои изменения чужому проекту необходимо все изменения в клонированном "форкнутом" репозитории делать в отдельной ветке (которую необходимо создать после клонирования). 

5. Чтобы добавить свои изменения на GitHub (в "форкнутый" репозиторий в своём аккаунте) нужно использовать команду `git push`. Так как мы вносили изменения в отдельную ветку, то GIt порекомендует нам выполнить данную команду в усложнённом виде. 

6. После добавления изменений в "форкнутый" репозиторий обновляем страницу GitHub и видим свои изменения (созданные локально ветки тоже добавляются). 

7. После этого, используя **pull request** предлагаем свои изменения автору проекта (обязательно с описанием изменений). 

## Пришло время испытать силу PULL REQUEST в деле:

Итак...

* я создал Папку на ноуте

* создал в ней репозиторий

* клонировал в него форкнутый репозиторий с твоего аакаунта

* понял, что что-то идет не так...

* пролистал лекцию и семинар 3 

* создал новую папку

* клонировал в неё форкнутый репозиторий

* создал ветку 

* добавил файл с инструкцией к GIT. Здесь стоит отметить, что легких путей я не искал и пытался найти ту волшебную кнопку, которая добавит нужный файл силами GIT. Не нашел. Смирился, и просто скопировал оттуда-сюда. 

* Дописал данный текст

* и теперь приступаю к посвящению себя в рыцари ордена Пулл Реквест. А именно:

    - солью дополнительную ветку в основную

    - сделаю коммит

    - сделаю пуш в форкнутый репозиторий

    - сделаю pull request и будет мне счастье

    




---
На GitHub принято, чтобы внутри каждого проекта был файл с описанием и инструкциями - README.md. Имя данного файла принято писать заглавными буквами. 

Перед клонированием удалённых репозиториев важно проверить состояние текущей папки на наличие в ней уже созданного репозитория. 

## Немного о Markdown
---
### Markdown — язык разметки, созданный с целью обозначения форматирования в простом тексте.


В данном разделе я приведу некоторые примеры синтаксиса языка Markdown: 

Таблицы:
| Заголовок 1 | Заголовок 2 |
| ----------- | ----------- |
| Ячейка 1 | Ячейка 2 |
| Ячейка 3 | Ячейка 4 | 

## Заголовок –выделение заголовков. Количество символов “#” задаёт уровень заголовка  (поддерживается 6 уровней).  

--- подчёркиванием этими символами (не менее 3 подряд) выделяют заголовки второго (“-”) уровней.  

**Полужирное начертание** или __Полужирное начертание__ 

*Курсивное начертание* или _Курсивное начертание_  

***Полужирное курсивное начертание***  

~~Зачёркнутый текст~~  

Описывать весь синтаксис не вижу смысла так как в интернете достаточно много инофрмации о Markdown. А по памяти, помню только это. Но я изучаю синтаксис дальше.

## Заключение

В принципе работать в Git несложно даже такому "чайнику" как я. Но написание данной (типа) инструкции показало, что у меня есть пробелы в понимании природы конфликтов, знании синтаксиса Markdown, а также я понимаю, что домашнее задание - 3 я буду выполнять по данной инструкции и с повторным просмотром лекции и семинара по данной теме. **_Короче, читатель - здесь очень хорошо подходит утверждение, что Знать, Уметь и Пользоваться - это 3 далекостоящие друг от друга состояния._**